
# 第一章 类

## 1.1 如何定义类

类的定义格式如下:

```java
修饰符 class 类名 {
    // 1.成员变量（属性）
    // 2.成员方法 (行为) 
    // 3.构造方法 （初始化类的对象数据的）
}
```

## 1.2 如何通过类创建对象

```java
类名 对象名称 = new 类名();
```

## 1.3 封装

#### 1.3.1 封装的步骤

1.使用 `private` 关键字来修饰成员变量。

2.使用`public`修饰getter和setter方法。

#### 1.3.2 封装的步骤实现

1. private修饰成员变量

```java
public class Student {
    private String name;
    private int age;
}
```

2. public修饰getter和setter方法

```java
public class Student {
    private String name;
    private int age;

    public void setName(String n) {
      	name = n;
    }

    public String getName() {
      	return name;
    }

    public void setAge(int a) {
        if (a > 0 && a <200) {
            age = a;
        } else {
            System.out.println("年龄非法！");
        }
    }

    public int getAge() {
      	return age;
    }
}
```

## 1.4 构造方法

### 1.4.1 构造方法的作用

在创建对象的时候，给成员变量进行初始化。

初始化即赋值的意思。

### 1.4.2 构造方法的格式

```java
修饰符 类名(形参列表) {
    // 构造体代码，执行代码
}
```

## 1.5 this关键字的作用

### 1.5.1 this关键字的作用

==this==代表所在类的当前对象的引用（地址值），即代表当前对象。

### 1.5.2 this关键字的应用

#### 1.5.2.1 用于普通的gettter与setter方法

this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。

```java
public class Student {
    private String name;
    private int age;

    public void setName(String name) {
      	this.name = name;
    }

    public String getName() {
      	return name;
    }

    public void setAge(int age) {
        if (age > 0 && age < 200) {
            this.age = age;
        } else {
            System.out.println("年龄非法！");
        }
    }

    public int getAge() {
      	return age;
    }
}
```

#### 1.5.2.2 用于构造方法中

this出现在构造方法中，代表构造方法正在初始化的那个对象。

```java
public class Student {
    private String name;
    private int age;
    
    // 无参数构造方法
    public Student() {} 
    
    // 有参数构造方法
    public Student(String name,int age) {
    	this.name = name;
    	this.age = age; 
    }
}
```

# 第二章 static关键字 P1-static-静态变量

## 2.1 概述

面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）

每个对象都有的属性，应该属于每个对象

所以Java中成员（**变量和方法**）等是存在所属性的，Java是通过static关键字来区分的。**static关键字在Java开发非常的重要，对于理解面向对象非常关键**

关于 `static` 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是**属于类**的是放在静态区中，没有static修饰的成员变量和方法则是**属于对象**的

## 2.2 概念

static表示静态，是Java中的一个修饰符，可以修饰成员方法，成员变量

### 2.2.1 分类：

1. 被static修饰的成员变量，叫做静态变量
2. 被static修饰的成员方法，叫做静态方法

## 2.3 静态变量

### 2.3.1 静态变量及其访问

有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为**类变量**或者**静态成员变量**。 直接用类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。

**如何使用呢**

例如现在我们需要定义传智全部的学生类，那么这些学生类的对象的学校属性应该都是“传智”，这个时候我们可以把这个属性定义成static修饰的静态成员变量。

**定义格式**

```java
修饰符 static 数据类型 变量名 = 初始值;
```

**静态成员变量的访问:**

类名调用（推荐）、对象名调用

**格式**：`类名.静态变量` 、 `对象名.静态变量`

### 2.3.2 实例变量及其访问

无static修饰的成员变量属于每个对象的，  这个成员变量叫**实例变量**，之前我们写成员变量就是实例成员变量。

**需要注意的是**：实例成员变量属于每个对象，必须创建类的对象才可以访问。   

**格式：对象.实例成员变量**

### 2.3.3特点：

1. 静态变量是随着类的加载而加载的，优先于对象存在
2. 被该类所有对象共享
3. 不属于对象，属于类

## 2.4 静态方法 P2_static-静态方法和工具类

### 2.4.1 静态方法及其访问

有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为**类方法**或者**静态方法**。 直接用  类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。

特点：

- 多用在测试类和工具类中
- Javabean类中很少会用

与静态成员变量一样，静态方法也是直接通过**类名.方法名称**即可访问。

**静态成员变量的访问:**

类名调用（推荐）、对象名调用

*格式*： `类名.静态方法`

### 2.4.2 实例方法及其访问

无static修饰的成员方法属于每个对象的，这个成员方法也叫做**实例方法**。

**需要注意的是**：实例方法是属于每个对象，必须创建类的对象才可以访问。  

*格式*： `对象.实例方法`

## 2.5 工具类

> 帮助我们做一些事情的，但是不描述任何事物的类

Javabean类：用来描述一类事物的类

测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口

工具类：不是用来描述一类事物的，而是帮我们做一些事情的类

**注**：

1. 类名见名知意
2. 私有化构造方法
3. 方法定义为静态

## 2.6 总结

1. 当 `static` 修饰成员变量或者成员方法时，该变量称为**静态变量**，该方法称为**静态方法**。该类的每个对象都**共享**同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。

2. 无static修饰的成员变量或者成员方法，称为**实例变量，实例方法**，实例变量和实例方法必须创建类的对象，然后通过对象来访问。

3. static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它==优先于对象存在==，所以，可以被所有对象共享。

4. 无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。

### 2.6.1 注意事项 P3 static的注意事项

- 静态方法**只能**访问静态变量和静态方法
- 非静态方法**可以**访问静态变量或者静态方法，**也可以**访问非静态的成员变量和非静态的成员方法
- 静态方法中是没有this关键字
- 静态：随着类的加载而加载； 非静态：跟对象有关的

总结:

1. 静态方法中，只能访问静态（静态方法不能调用非静态成员/实例变量）
2. 非静态方法可以访问所有
3. 静态方法中没有this关键字（this：表示当前方法调用者的地址值，是由虚拟机赋值的）

### 2.6.2 重新认识main方法

~~~java
public static void main(String[] args){}
~~~

- public：被JVM调用，访问权限足够大

- static：被JVM调用，不用创建对象，直接类名访问

  ​			  因为main方法是静态的，所以测试类中其他方法也需要是静态的

- void：被JVM调用，不需要给JVM返回值

- main：一个通用的名称，虽然不是关键字，但是被JVM识别

- String[]s args：以前用于接收键盘录入数据的，现在没用

# 第三章 继承 P4-继承的概述

> Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系

封装：对象代表什么，就得封装对应的数据，并提供数据对应的行为

## 3.1 概述

### 3.1.1 讲解

假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要**继承**那一个类即可。如图所示：
![](../img/day 13/1.jpg)

~~~java
public class 子类 extends 父类 {}
~~~

多个类可以称为**子类（派生类）**，单独被继承的那一个类称为**父类**、**超类（superclass）**或者**基类**。

### 3.1.2 继承的含义

继承描述的是事物之间的所属关系，这种关系是：`is-a` 的关系。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系

**继承**：就是子类继承父类的**属性**和**行为**，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的**非私有**的属性和行为

**核心**：共性内容抽取、子类是父类的一种

### 3.1.3 继承的好处

1. 继承是面向对象三大特征之一，可以让类跟类之间产生子父的关系
2. 可以把多个子类中重复的代码抽取到父类中了，提高**代码的复用性**（减少代码冗余，相同代码重复利用）
3. 子类可以在父类的基础上，增加其他的功能，使子类更强大
4. 使类与类之间产生了关系

### 3.1.4 小结

1. 继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。

2. 子类继承父类，就可以直接得到父类的成员变量和方法

3. 当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码

继承后子类的特点：

- 子类可以得到父类的属性和行为，子类可以使用
- 子类可以在父类的基础上新增其他功能，子类更强大

## 3.2 继承的格式

通过 `extends` 关键字，可以声明一个子类继承另外一个父类，定义格式如下：
```java
public class 父类 {
	...
}

public class 子类 extends 父类 {
	...
}
```

**需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。**

## 3.3 继承的特点 P5-继承的特点和继承体系的设计

Java只支持单继承，不支持多继承，但支持多层继承

  > 顶层父类是Object类。所有的类默认继承Object，作为父类

​	单继承：一个子类只能继承一个父类

​	不支持多继承：子类不能同时继承多个父类

​	多层继承：子类A继承父类B，父类B可以继承父类C（A直接父类B，A间接父类C）

每一个类都直接或者间接的继承于Object

### 3.3.1 继承体系

![继承体系](..\img\day 13\继承体系.PNG)

### 3.3.2 注意

​	子类只能访问父类中非私有的成员

## 3.4 子类不能继承的内容 P6-子类到底能继承父类中的那些内容

![子类继承父类的内容](..\img\day 13\子类继承父类.PNG)

- **父类的构造方法不能被子类继承**
- **只要父类中的虚方法才能被子类继承**（虚方法：非private、非static、非final）

**值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。**

## 3.5 继承后的特点—成员变量 P7-继承中成员变量和成员方法的访问特点

就近原则：（谁离我近，我就用谁）

​	先在局部位置找，本类成员位置找，父类成员位置找，逐级往上

### 3.5.1 成员变量不重名

如果子类父类中出现**不重名**的成员变量，这时的访问是**没有影响的**

### 3.5.2 成员变量重名

如果子类父类中出现**重名**的成员变量，这时的访问是**有影响的**

子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量

重名成员变量：从局部位置网上找

this.重名成员变量：从本类成员位置开始网上找

super.重名成员变量：从父类成员位置开始网上找

### 3.5.3  super访问父类成员变量

子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用`super` 关键字，修饰父类成员变量，类似于之前学过的 `this` 。

需要注意的是：**super代表的是父类对象的引用，this代表的是当前对象的引用。**

**使用格式：**

```java
super.父类成员变量名
```

> 小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，可以在父类中提供公共的getXxx方法和setXxx方法。

## 3.6 继承后的特点—成员方法

直接调用满足就近原则：谁离我近，我就用谁

super调用，直接访问父类

### 3.6.1 成员方法不重名

如果子类父类中出现**不重名**的成员方法，这时的调用是**没有影响的**。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法

### 3.6.2 成员方法重名

如果子类父类中出现**重名**的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法

## 3.7 方法重写

> 当父类的方法不能满足子类现在的需求时，需要进行方法重写

### 3.7.1 概念

**方法重写** ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。**声明不变，重新实现**。

### 3.7.2 书写格式

> 在继承体系中，子类出现了和父类一模一样的方法声明，我们就称子类这个方法是**重写的方法**

子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方法。

### 3.7.3 @Override重写注解

* @Override：注解，重写注解校验！
* 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。
* 加上注解后如果有红色波浪线，表示语法错误
* 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错

### 3.7.4 注意事项

1. 方法重写是发生在子父类之间的关系
2. 子类中重写的方法上面需要加上@Override
3. 重写方法的名称，形参列表必须与父类中的一致
4. 子类重写父类方法时，访问权限子类必须大于等于父类（空着不写<protected<public）
5. 子类重写父类方法时，返回值类型子类必须小于等于父类
6. 建议：**重写的方法尽量和父类保持一致**
7. 只要被添加到虚方法表中的方法才能被重写
8. 本质：**覆盖虚方法表中的方法**

## 3.8 继承后的特点—构造方法 P8-继承中的构造方法和this super关键字
### 3.8.1 访问特点

1. 构造方法的名字是与类名一致的。所以父类的构造方法不会被子类继承
2. 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己
   - 子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据
   - 子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化
3. 调用父类构造方法
   - 子类构造方法的第一行语句默认都是：super()，不写也存在，且必须在第一行
   - 如果想调用父类有参构造，必须手动写super进行调用

**子类所有构造方法的第一行都会默认先调用父类的无参构造方法（先有爸爸，再有儿子）**

### 3.8.2 小结

* 子类构造方法执行的时候，都会在第一行默认先调用父类无参数构造方法一次。
* 子类构造方法的第一行都隐含了一个**super()**去调用父类无参数构造方法，**super()**可以省略不写。

## 3.9 super(...)和this(...)

this：理解为一个变量，表示当前方法调用者的地址值

super：代表父类存储空间

### 3.9.1 super和this的用法格式

super和this完整的用法如下

```java
this.成员变量    	--    本类的
super.成员变量    	--    父类的

this.成员方法名()  	--    本类的    
super.成员方法名()   --    父类的
```

接下来我们使用调用构造方法格式：

```java
super(...) -- 调用父类的构造方法，根据参数匹配确认
this(...) -- 调用本类的其他构造方法，根据参数匹配确认
```

| 关键字 |            访问成员变量             |               访问成员方法               |          访问构造方法           |
| :----: | :---------------------------------: | :--------------------------------------: | :-----------------------------: |
|  this  | this.成员变量<br/>访问本类成员变量  | this.成员方法(...)<br/>访问本类成员方法  |  this(...)<br/>访问本类构方法   |
| super  | super.成员变量<br/>访问父类成员变量 | super.成员方法(...)<br/>访问父类成员方法 | super(...)<br/>访问父类构造方法 |

### 3.9.2 注意

- **子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。**

- **super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。**

- super(..)是根据参数去确定调用父类哪个构造方法的。


### 3.9.3 super(...)案例图解

**父类空间优先于子类对象产生**

在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造方法

**理解图解如下**：

![](../img/day 13/2.jpg)



### 3.9.4 this(...)用法演示

this(...)
 *    默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。
 *    为了借用其他构造方法的功能。

```java
package com.itheima._08this和super调用构造方法;
/**
 * this(...):
 *    默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。
 *    为了借用其他构造方法的功能。
 *
 */
public class ThisDemo01 {
    public static void main(String[] args) {
        Student xuGan = new Student();
        System.out.println(xuGan.getName()); // 输出:徐干
        System.out.println(xuGan.getAge());// 输出:21
        System.out.println(xuGan.getSex());// 输出： 男
    }
}

class Student{
    private String name ;
    private int age ;
    private char sex ;

    public Student() {
  // 很弱，我的兄弟很牛逼啊，我可以调用其他构造方法：Student(String name, int age, char sex)
        this("徐干",21,'男');
    }

    public Student(String name, int age, char sex) {
        this.name = name ;
        this.age = age   ;
        this.sex = sex   ;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }
}
```

### 3.9.5 小结

* **子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。**

* **super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。**

* **super(..)和this(...)是根据参数去确定调用父类哪个构造方法的。**
* super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。
* this(..)可以调用本类中的其他构造方法。













