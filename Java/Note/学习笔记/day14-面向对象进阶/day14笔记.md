# 第一章 多态 P1-认识多态

> 同类型的对象，表现出的不同形态

## 1.1 多态的形式

> **多态是继封装、继承之后，面向对象的第三大特性**
>
> **多态是出现在继承或者实现关系中的**

**多态的格式**：

```java
父类类型 变量名 = new 子类/实现类构造器;
```

~~~java
变量名.方法名();
~~~

## 1.2 多态的使用场景

**要注意的是：**

* 当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。
* 当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象（后面会学）。
* 而且多态还可以根据传递的不同对象来调用不同类中的方法。

## 1.3 多态的定义和前提

**多态**： 是指同一行为，具有多个不同表现形式。

**前提：**

1. 有继承或者实现关系

2. 方法的重写【意义体现：不重写，无意义】

3. 父类引用指向子类对象【格式体现】

   > 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。

**好处**

- 使用父类型作为参数，可以接收所有子类对象
- 体现多态的扩展性与便利

## 1.4 多态的运行特点 P2-多态中调用成员的特点

调用成员==变量==时：编译看左边，运行看左边

在子类的对象中，会把父类的成员变量也继承下的。

（父：name 子：name 成员变量有两个name，所以调用对象类型的name即父的name）

调用成员==方法==时：编译看左边，运行看右边

如果子类对方法进行了重写，那么在虚方法表中是会把父类的方法进行覆盖的。

## 1.5 多态的优势和弊端 P3-多态的优势和弊端

### 优势

在多态形式下，右边对象可以实现解耦合，便于扩展和维护

定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利

### 弊端

多态编译阶段是看左边父类类型的，如果子类有独有的功能，那么在编译的时候会先检查左边的父类中有没有这个方法，如果没有直接报错，此时**多态的写法就无法访问子类独有功能了**

## 1.6 引用类型转换（弊端的解决方案）

### 1.6.1 转型的意义

**多态的写法就无法访问子类独有功能了。**

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，**不能调用**子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。

- 自动转换: 范围小的赋值给范围大的.自动完成:double d = 5; 
- 强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14 

​     多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。

### 1.6.2 向上转型（自动转换）

- **向上转型**：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。
  当父类引用指向一个子类对象时，便是向上转型。
  *使用格式*：

```java
父类类型  变量名 = new 子类类型();
```

原因是：**父类类型相对与子类来说是大范围的类型**所以子类范围小可以直接自动转型给父类类型的变量

### 1.6.3 向下转型（强制转换）

- **向下转型**：父类类型向子类类型向下转换的过程，这个过程是强制的。
  一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。

*使用格式*：

~~~java
父类类型  变量名 = new 子类类型();
~~~

```java
子类类型 变量名 = (子类类型) 父类变量名;
```

*细节*：转换的时候不能瞎转，如果转成其他类的类型，就会报错

### 1.6.4 使用情况

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，**不能调用**子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。

### 1.6.5 转型的异常

转型的过程中，一不小心就会遇到这样的问题，请看如下代码：

```java
public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal a = new Cat();  
        a.eat();               // 调用的是 Cat 的 eat

        // 向下转型  
        Dog d = (Dog)a;       
        d.watchHouse();        
        // 调用的是 Dog 的 watchHouse 【运行报错】
    }  
}
```

这段代码可以通过编译，但是运行时，却报出了 `ClassCastException` ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。

### 1.6.6 instanceof关键字

为了避免ClassCastException的发生，Java提供了 `instanceof` 关键字，给引用变量做类型的校验，格式如下：

```java
变量名 instanceof 数据类型 
如果变量属于该数据类型或者其子类类型，返回true。
如果变量不属于该数据类型或者其子类类型，返回false。
```

### 1.6.7 instanceof新特性

JDK14的时候提出了新特性，把判断和强转合并成了一行

格式：

~~~java
父类对象名 instanceof 将要转换的子类对象类型 转换完成的子类对象名 
~~~

# 第二章 包 P5-包和final

> 包就是文件夹。用来管理各种不同功能的Java类，方便后期代码维护

## 2.1 包

​	包在操作系统中其实就是一个文件夹。**包是用来分门别类的管理技术，不同的技术类放在不同的包下**，方便管理和维护。

在IDEA项目中，建包的操作如下：

![](img/aaa.jpg)

**包名的命名规范**：

```java
路径名.路径名.xxx.xxx
```

- 包名一般是公司域名的倒写，公司域名反写 + 包的作用，需要全部英文小写，见名知意
- 包名必须用”.“连接
- 包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字

## 2.2 使用其他类的规则

> 使用其他类时，需要使用全类名

1. 使用全类名的形式即可
2. 全类名：包名 + 类名
3. 拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference

***注***：

- 使用同一个包中的类时，不需要导包
- 使用java.lang包中的类时，不需要导包
- 其他情况都需要导包
- 如果同时使用两个包中的同名类，需要用==全类名==

## 2.3 导包

什么时候需要导包？

​	情况一：在使用Java中提供的非核心包中的类时

​	情况二：使用自己写的其他包中的类时

什么时候不需要导包？

​	情况一：在使用Java核心包（java.lang）中的类时

​	情况二：在使用自己写的同一个包中的类时

# 第三章 final关键字

## 3.1 概述

​	学习了继承后，我们知道，子类可以在父类的基础上改写父类内容

​	Java提供了`final` 关键字，表示修饰的内容**不可被改变的**

- **final**：  不可改变，最终的含义。
  - 可以用于修饰类、方法和变量
  - 类：被修饰的类，不能被继承。
  - 方法：被修饰的方法，不能被重写。
  - 变量：被修饰的变量，有且仅能被赋值一次。

### 3.1.1 修饰分类

方法：表明该方法是最终方法，不能被重写

类：表明该类是最终类，不能被继承

变量：叫做常量，只能被赋值一次

## 3.2 使用方式

### 3.2.1 修饰类

> final修饰的类是最终类，不能被继承
>

格式如下：

```java
final class 类名 {
}
```

代码:

```java
final class Fu {
}
// class Zi extends Fu {} // 报错,不能继承final的类
```

查询API发现像 `public final class String` 、`public final class Math` 、`public final class Scanner` 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。

### 3.2.2 修饰方法

> final修饰的方法是最终方法，不能被重写

格式如下：

```java
修饰符 final 返回值类型 方法名(参数列表){
    //方法体
}
```

代码: 

```java
class Fu2 {
	final public void show1() {
		System.out.println("Fu2 show1");
	}
	public void show2() {
		System.out.println("Fu2 show2");
	}
}

class Zi2 extends Fu2 {
//	@Override
//	public void show1() {
//		System.out.println("Zi2 show1");
//	}
	@Override
	public void show2() {
		System.out.println("Zi2 show2");
	}
}
```

### 3.2.3 修饰变量

> 叫做常量，只能被赋值一次

#### 3.2.3.1 常量

> 实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性

**常量的命名规范**：

- 单个单词：全部大写
- 多个单词：全部大写，单词之间用下划线隔开

**细节**：
final修饰的变量是基本类型：那么变量存储的==数据值==不能发生改变

final修饰的变量是引用类型：那么变量存储的==地址值==不能发生改变，对象内部的可以改变

核心：常量记录的数据是不能发生改变的

#### 3.2.3.2 局部变量

1. **局部变量——基本类型**
   基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改

#### 3.2.3.3 成员变量

成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：

- 显示初始化(在定义成员变量的时候立马赋值)（常用）；

```java
public class Student {
    final int num = 10;
}
```

- 构造方法初始化(在构造方法中赋值一次)（不常用，了解即可）。

  **注意：每个构造方法中都要赋值一次！**

```java
public class Student {
    final int num = 10;
    final int num2;

    public Student() {
        this.num2 = 20;
//     this.num2 = 20;
    }
    
     public Student(String name) {
        this.num2 = 20;
//     this.num2 = 20;
    }
}
```

> 被final修饰的常量名称，一般都有书写规范，所有字母都**大写**。

# 第四章 权限修饰符

## 3.1 权限修饰符

​	在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。

- public：公共的，所有地方都可以访问。

- protected：本类 ，本包，其他包中的子类都可以访问。

- 默认（没有修饰符）：本类 ，本包可以访问。

  注意：默认是空着不写，不是default

- private：私有的，当前类可以访问。
  `public > protected > 默认 > private`

## 3.2 不同权限的访问能力

|                  | public | protected | 默认 | private |
| ---------------- | ------ | --------- | ---- | ------- |
| 同一类中         | √      | √         | √    | √       |
| 同一包中的类     | √      | √         | √    |         |
| 不同包的子类     | √      | √         |      |         |
| 不同包中的无关类 | √      |           |      |         |

可见，public具有最大权限。private则是最小权限。

编写代码时，如果没有特殊的考虑，建议这样使用权限：

- 成员变量使用`private` ，隐藏细节。
- 构造方法使用` public` ，方便创建对象。
- 成员方法使用`public` ，方便调用方法。

> 小贴士：不加权限修饰符，就是默认权限





